pipeline {
    agent any

    environment {
        sshuser = "" // Declare variables so they are global
        sshpass = ""
        shen = ""
        changelog = "This is an initial build" // This will be printed on the success notification
        branch = "CSR1000V-Development"
        // These are versions of the build (based on the folder hierarchy in the repo)
        version = "V1.1.0"
        fallback_version = "V0.1.0"
        githubRepoURL = "https://github.com/ZeroSighs/Group_45_MP.git"
        pbfilePath = "${WORKSPACE}/Router_Playbook/${version}/Router_Playbook.yml"
        htfilePath = "${WORKSPACE}/Router_Playbook/hosts"
        //Router addresses are used for ping purposes
        routerAddress0 = "10.0.2.3"
        routerAddress1 = "192.168.2.1"
        routerAddress2 = "192.168.1.1"
        // your github credentials should be stored within jenkins when you set up the plugin
        // Use its ID here
        githubCredentialsId = 'gitlol'
        // Will be removed as it doesnt do anything
        builderror = false
    }

    stages {
        stage('Applying fix') { // This is a jank fix as this script requires a python package but I cannot interact with the python environment jenkins uses from the machine
            steps {
                script {
                    sh "sudo apt install pip -y"
                    sh "sudo pip install ansible-pylibssh --break-system-packages"
                }
            }
        }

         stage('Checkout from GitHub') { // Pulls script from github
            steps {
                script {
                    dir("Router_Playbook/${version}") {
                        sh "cat Router_Playbook.yml"  // Display the content of the playbook file 
                        sh "cp Router_Playbook.yml ${WORKSPACE}/Router_Playbook.yml" // The playbook only runs from the root workspace folder hence its copied out. Same for the host file
                    }
                    sh "cat Router_Playbook/hosts"
                    sh "cp Router_Playbook/hosts ${WORKSPACE}/hosts" // Display the content of the hosts file
                }
            }
        }

        stage('Authenticate with Vault') { // Retrieve credentials from hashicorp vault - Make sure you have decrypted the vault
            steps {
                script {
                    
                        withVault(configuration: [disableChildPoliciesOverride: false, engineVersion: 1, timeout: 60, vaultCredentialId: 'vault-jenkins', vaultUrl: 'http://127.0.0.1:8200'], vaultSecrets: [[path: 'secret/ssh-keys/router-credentials', secretValues: [[envVar: 'SSH_USER', vaultKey: 'username'], [envVar: 'SSH_PASS', vaultKey: 'password'], [envVar: 'SSH_EN', vaultKey: 'enable']]]]) 
                            {
                            sshuser = env.SSH_USER // Environment variables behave strangely hence they are appended to regular variables
                            sshpass = env.SSH_PASS // not ideal but this works
                            sshen = env.SSH_EN 
                                
                            }
                            
                  
                    }
                }
            }
        
        stage('Run Ansible Playbook') { // The highlight of the show
            steps {
                // password variables are passed into the playbook run along with other vars (you can generate this using the syntax generator)
                script {
                    ansiblePlaybook([extraVars: [sshuser: "${sshuser}",sshpass: "${sshpass}", sshen: "${sshen}"], disableHostKeyChecking: true, installation: 'Ansible', inventory: 'hosts', playbook: 'Router_Playbook.yml', vaultTmpPath: '']) 
                }
            }
        }
        stage('Post-check') {
            steps {
                catchError(buildResult: 'SUCCESS', stageResult: 'FAILURE') {
                    script {
                    // Perform ping test from control machine to router address after playbook
                    def pingExitCode1 = sh(script: "ping -c 4 -I enp0s3 ${routerAddress0}", returnStatus: true)
                    def pingExitCode2 = sh(script: "ping -c 4 -I enp0s9 ${routerAddress1}", returnStatus: true)
                    //def pingExitCode3 = sh(script: "ping -c 4 -I enp0s8 ${routerAddress2}", returnStatus: true) 
                    // The last ping IP exists to test the failure handling which I can trigger by disabling the VM interface
            
                // Check the exit code of the ping command and fail the build if not successful
                    //if (pingExitCode1 != 0 || pingExitCode2 != 0 || pingExitCode3 != 0) {
                    if (pingExitCode1 != 0 || pingExitCode2 != 0) {
                        currentBuild.result = "FAILURE"
                        error("Ping test to router failed. Build marked as FAILURE.")
                        builderror = true
                        }
                    }
                }
            }
        }
        
        stage('Fallback if failed') {
            when {
                expression { currentBuild.resultIsWorseOrEqualTo('FAILURE') } // This is inconsistent between builds (sometimes work and sometimes doesnt) 
            }
            steps {
                script {
                    dir("Router_Playbook/${fallback_version}") {
                        sh "cat Router_Playbook.yml"  // Does the same thing as the first playbook run, but on a different version
                        sh "cp Router_Playbook.yml ${WORKSPACE}/Router_Playbook.yml"
                    }
                    sh "cat Router_Playbook/hosts"
                    sh "cp Router_Playbook/hosts ${WORKSPACE}/hosts" 
                    ansiblePlaybook disableHostKeyChecking: true, installation: 'Ansible', inventory: 'hosts', playbook: 'Router_Playbook.yml', vaultTmpPath: ''
                    echo "Build failed, configuration has been rolled back to previous version"
                    }
                    
                }
            }
            stage('Success Notification') {
            when {
                expression { currentBuild.resultIsBetterOrEqualTo('SUCCESS') }
            }
            steps {
                script {
                    // The API Link is generated when you create a bot. Keep this link safe as anyone can use the API Key (with the link) to send messages using the bot
                    msg = "New successful build on Branch $branch \n Build Number: ${currentBuild.number} \n Start Time: ${new Date(currentBuild.startTimeInMillis)} \n Build Duration: ${currentBuild.duration} ms \n Changelog: $changelog"
                    // format this as json and curl from the VM to send a message through the telegram
                    sh "curl -X POST -H 'Content-Type: application/json' -d '{\"chat_id\": \"6680816225\", \"text\": \"$msg\", \"disable_notification\": true}' https://api.telegram.org/bot6964667296:AAF8Bv8XibWEPeQ4CQCL5htOfEVJTrffhHs/sendMessage" 
                    }
                    
                }
            }
        }
    }
    

